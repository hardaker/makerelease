#!/usr/bin/perl

use strict;
use XML::Simple;
use Data::Dumper;
use Makerelease;

our $VERSION = "0.1";

my %opts = (c => "makerelease.xml");
my %parameters;
my $descr;

LocalGetOptions(\%opts,
	   ['c|config-file=s',        'makerelease xml config file to use'],
	   ['r|regexp-ignore-steps=s','Ignore these REGEXP steps'],
	   ['s|start-at=s',           'Skip all steps until ARG'],
	   ['p|parameters=s',         'Parameters: parameter=value,...'],
	   ['i|interactive',          'Prompt whether to do each step'],
 	   ['n|dry-run',     'Dry run only.  Don\'t actually do anything.'],
	   ['v|verbose',     'Verbose output about steps taken.'],
	   ['h|help', 'Help']) || exit;

my $extrajunk = shift;
die "Unexpected argument ($extrajunk)" if ($extrajunk);

######################################################################
# Parse the parameters
if ($opts{'p'}) {
    foreach my $def (split(/,\s*/,$opts{'p'})) {
	my ($name, $value) = ($def =~ /^([^=]+)=(.*)/);
	die "bad parameter spec: $def\n" if (!defined($name));
	$parameters{$name} = $value;
    }
}

######################################################################
# read in XML structure
if (!-f $opts{'c'}) {
    print STDERR "Can't find a configuration file: $opts{'c'}  (use the -c flag to specify one)\n";
    exit 1;
}

my $relinfo = XMLin($opts{'c'},
		    #XXX: should probably forcearray => 1 for everything
		    ForceArray => [qw(steps step commands command
				      modifications modify)]);

######################################################################
# Process steps
my $makerelease = new Makerelease(opts => \%opts, parameters => \%parameters);
$makerelease->process_steps($relinfo,'');


######################################################################
sub System {
    my $name = shift;
    my $cmd = $descr = join(" ", @_);
    my $rc;
    while (dostep($name)) {
	print STDERR "  running: ",$cmd,"\n";
	last if ($opts{'n'});
	system(@_);
	$rc = checkresult();
        last if ($rc == 0);
    }
}

sub checkresult {
    if ($?) {
	print STDERR "The above STEP failed.  Continue anyway (y/n/r)?  ";
	my $ans = <STDIN>;
        return 1 if ($ans =~ /^r/);
	if ($ans =~ /^n/) {
	    print STDERR "  EXITING\n";
	    exit;
	}
    }
   return 0;
}

sub start_step {
    my ($vernum, $vername) = @_;
    print STDERR "\n********** STEP: $vernum: $vername **********\n";
}

sub dostep {
    my $name = shift;
    print STDERR "\n********** STEP: $name ******************************\n";
    if ($descr) {
	print STDERR "  [$descr]\n";
	$descr = undef;
    }
    print "\n";
    if ($opts{'s'} && $name ne $opts{'s'}) {
	print STDERR "      [skipping]\n";
	return 0;
    }
    $opts{'s'} = '';
    if ($opts{r} && $name =~ /$opts{r}/) {
	print STDERR "      [skipping]\n";
	return 0;
    } elsif ($opts{'i'}) {
	print STDERR "  Do this step (y/n/q)?  ";
	my $ans = <STDIN>;
	if ($ans =~ /^n/) {
	    print STDERR "      [skipping]\n";
	    return 0;
	}
	if ($ans =~ /^q/) {
	    print STDERR "      QUITTING\n";
	    exit;
	}
    }
    return 1;
}

sub manualstep {
    my $tag = shift;

    if (dostep($tag)) {
	print STDERR "\n\n",join(" ",@_);

	print STDERR "\n\n  Hit return when done:  ";

	return 1 if ($opts{'n'});

	my $bogus = <STDIN>;
	return 1;
    }
    return 0;
}

sub getinput {
    my $prompt = shift;
    print "$prompt\n" if ($prompt);
    my $bogus = <STDIN>;
    return $bogus;
}

sub DEBUG {
    if ($opts{'v'}) {
	print @_;
    }
}

#######################################################################
# getopt long gui portability code
#
sub LocalGetOptions {
    if (eval {require Getopt::GUI::Long;}) {
	import Getopt::GUI::Long;
	Getopt::GUI::Long::Configure(qw(display_help no_ignore_case));
	return GetOptions(@_);
    } else {
	require Getopt::Long;
	Getopt::Long::Configure(qw(auto_help no_ignore_case));
	import Getopt::Long;
    }
    GetOptions(LocalOptionsMap(@_));
}

sub LocalOptionsMap {
    my ($st, $cb, @opts) = ((ref($_[0]) eq 'HASH')
			    ? (1, 1, $_[0]) : (0, 2));
    for (my $i = $st; $i <= $#_; $i += $cb) {
	if ($_[$i]) {
	    next if (ref($_[$i]) eq 'ARRAY' && $_[$i][0] =~ /^GUI:/);
	    push @opts, ((ref($_[$i]) eq 'ARRAY') ? $_[$i][0] : $_[$i]);
	    push @opts, $_[$i+1] if ($cb == 2);
	}
    }
    return @opts;
}
